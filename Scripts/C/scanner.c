#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <errno.h>
#include <ctype.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <limits.h>
#include <signal.h>

#define MAX_IPS 4096
#define LINE_BUF 2048

#define CLR_RED    "\033[1;31m"
#define CLR_YELLOW "\033[1;33m"
#define CLR_GREEN  "\033[1;32m"
#define CLR_GRAY   "\033[0;37m"
#define CLR_RESET  "\033[0m"

typedef enum { CLS_UNKNOWN = 0, CLS_RED = 1, CLS_YELLOW = 2, CLS_GREEN = 3, CLS_GRAY = 4 } os_class_t;

struct ip_entry {
    char ip[INET_ADDRSTRLEN];
    os_class_t cls;
    char os_str[256];
};

static int sanitize_iface(const char *s) {
    if (!s || !*s) return 0;
    for (; *s; ++s) {
        if (!(isalnum((unsigned char)*s) || *s == '_' || *s == '-' || *s == '.')) return 0;
    }
    return 1;
}

static int find_or_add_entry(struct ip_entry *entries, int *count, const char *ip) {
    for (int i = 0; i < *count; ++i) {
        if (strcmp(entries[i].ip, ip) == 0) return i;
    }
    if (*count >= MAX_IPS) return -1;
    strncpy(entries[*count].ip, ip, INET_ADDRSTRLEN-1);
    entries[*count].ip[INET_ADDRSTRLEN-1] = '\0';
    entries[*count].cls = CLS_UNKNOWN;
    entries[*count].os_str[0] = '\0';
    (*count)++;
    return (*count) - 1;
}

static char *write_temp_caplet(const char *iface, int seconds) {
    const char *tmpdir = getenv("TMPDIR");
    if (!tmpdir) tmpdir = "/tmp";

    char template_path[PATH_MAX];
    if (snprintf(template_path, sizeof(template_path), "%s/bettercap_caplet_XXXXXX.cap", tmpdir) >= (int)sizeof(template_path)) {
        fprintf(stderr, "Temporary file path too long\n");
        return NULL;
    }

    int fd = mkstemps(template_path, 4);
    if (fd == -1) {
        fprintf(stderr, "mkstemps(%s) failed: %s\n", template_path, strerror(errno));
        return NULL;
    }

    FILE *f = fdopen(fd, "w");
    if (!f) {
        fprintf(stderr, "fdopen failed for %s: %s\n", template_path, strerror(errno));
        close(fd);
        unlink(template_path);
        return NULL;
    }

    fprintf(f,
        "# autogenerated caplet\n"
        "set events.stream false\n"
        "set http.server.enabled false\n"
        "net.probe on\n"
    );
    fprintf(f, "sleep %d\n", seconds);
    fprintf(f,
        "net.show\n"
        "net.probe off\n"
        "quit\n"
    );

    fflush(f);
    fclose(f);

    return strdup(template_path);
}

static int run_bettercap_and_collect(const char *iface, const char *caplet_path, struct ip_entry *entries, int *entry_count) {
    if (access(caplet_path, R_OK) != 0) {
        fprintf(stderr, "caplet %s not readable: %s\n", caplet_path, strerror(errno));
        return -1;
    }

    int p[2];
    if (pipe(p) == -1) {
        perror("pipe");
        return -1;
    }

    pid_t pid = fork();
    if (pid == -1) {
        perror("fork");
        close(p[0]); close(p[1]);
        return -1;
    }

    if (pid == 0) {
        close(p[0]);
        if (dup2(p[1], STDOUT_FILENO) == -1) _exit(127);
        if (dup2(p[1], STDERR_FILENO) == -1) _exit(127);
        close(p[1]);
        char *const argv[] = { "bettercap", "-iface", (char *)iface, "-caplet", (char *)caplet_path, NULL };
        execvp("bettercap", argv);
        perror("execvp(bettercap)");
        _exit(127);
    }

    close(p[1]);
    FILE *rf = fdopen(p[0], "r");
    if (!rf) {
        perror("fdopen");
        close(p[0]);
        kill(pid, SIGTERM);
        waitpid(pid, NULL, 0);
        return -1;
    }

    char line[LINE_BUF];
    while (fgets(line, sizeof(line), rf) != NULL) {
        fputs(line, stdout);
        char *saveptr = NULL;
        char *tok = strtok_r(line, " \t\r\n,;:[]()", &saveptr);
        while (tok) {
            struct in_addr a;
            if (inet_pton(AF_INET, tok, &a) == 1) {
                if (find_or_add_entry(entries, entry_count, tok) == -1) {
                    fprintf(stderr, "IP entry buffer full, stopping collection\n");
                    fclose(rf);
                    waitpid(pid, NULL, 0);
                    return -1;
                }
            }
            tok = strtok_r(NULL, " \t\r\n,;:[]()", &saveptr);
        }
    }

    fclose(rf);
    int status = 0;
    waitpid(pid, &status, 0);
    if (WIFEXITED(status) && WEXITSTATUS(status) != 0)
        fprintf(stderr, "bettercap exited with code %d\n", WEXITSTATUS(status));
    return 0;
}

static int write_hosts_file(const char *path, struct ip_entry *entries, int entry_count) {
    FILE *f = fopen(path, "w");
    if (!f) {
        perror("fopen hosts");
        return -1;
    }
    for (int i = 0; i < entry_count; ++i) {
        if (fprintf(f, "%s\n", entries[i].ip) < 0) {
            perror("fprintf hosts");
            fclose(f);
            return -1;
        }
    }
    fclose(f);
    return 0;
}

static os_class_t classify_os_from_line(const char *line) {
    if (!line) return CLS_GRAY;
    if (strstr(line, "Windows XP") || strstr(line, "Windows 7") || strstr(line, "Windows 8"))
        return CLS_RED;
    if (strstr(line, "Windows 10") || strstr(line, "Windows 11"))
        return CLS_YELLOW;
    if (strstr(line, "Linux") || strstr(line, "BSD") || strstr(line, "Mac OS") || strstr(line, "Darwin"))
        return CLS_GREEN;
    if (strstr(line, "Too many fingerprints") || strstr(line, "No OS matches") || strstr(line, "No exact OS matches"))
        return CLS_GRAY;
    return CLS_GRAY;
}

static const char *class_color(os_class_t c) {
    switch (c) {
        case CLS_RED: return CLR_RED;
        case CLS_YELLOW: return CLR_YELLOW;
        case CLS_GREEN: return CLR_GREEN;
        case CLS_GRAY: return CLR_GRAY;
        default: return CLR_GRAY;
    }
}
static const char *class_name(os_class_t c) {
    switch (c) {
        case CLS_RED: return "Red";
        case CLS_YELLOW: return "Yellow";
        case CLS_GREEN: return "Green";
        case CLS_GRAY: return "Gray";
        default: return "Gray";
    }
}

static int run_nmap_and_update(const char *argv0, char *const argv[], struct ip_entry *entries, int entry_count) {
    int p[2];
    if (pipe(p) == -1) { perror("pipe"); return -1; }

    pid_t pid = fork();
    if (pid == -1) { perror("fork"); close(p[0]); close(p[1]); return -1; }

    if (pid == 0) {
        close(p[0]);
        if (dup2(p[1], STDOUT_FILENO) == -1) _exit(127);
        if (dup2(p[1], STDERR_FILENO) == -1) _exit(127);
        close(p[1]);
        execvp(argv0, argv);
        perror("execvp(nmap)");
        _exit(127);
    }

    close(p[1]);
    FILE *rf = fdopen(p[0], "r");
    if (!rf) { perror("fdopen"); close(p[0]); kill(pid, SIGTERM); waitpid(pid,NULL,0); return -1; }

    char line[LINE_BUF];
    char current_ip[INET_ADDRSTRLEN] = {0};

    while (fgets(line, sizeof(line), rf)) {
        if (sscanf(line, "Nmap scan report for %15s", current_ip) == 1) {
            fputs(line, stdout);
            continue;
        }

        if (strstr(line, "OS details:") != NULL) {
            const char *start = strstr(line, "OS details:") + strlen("OS details:");
            while (*start && isspace((unsigned char)*start)) start++;
            char osdesc[256];
            strncpy(osdesc, start, sizeof(osdesc)-1);
            osdesc[sizeof(osdesc)-1] = '\0';
            osdesc[strcspn(osdesc, "\r\n")] = '\0';

            os_class_t cls = classify_os_from_line(osdesc);
            const char *color = class_color(cls);
            printf("%sOS details: %s%s\n", color, osdesc, CLR_RESET);

            if (current_ip[0]) {
                int idx = -1;
                for (int i = 0; i < entry_count; ++i) {
                    if (strcmp(entries[i].ip, current_ip) == 0) { idx = i; break; }
                }
                if (idx >= 0) {
                    if (cls != CLS_GRAY || entries[idx].cls == CLS_UNKNOWN || entries[idx].cls == CLS_GRAY) {
                        entries[idx].cls = cls;
                    }
                    strncpy(entries[idx].os_str, osdesc, sizeof(entries[idx].os_str)-1);
                    entries[idx].os_str[sizeof(entries[idx].os_str)-1] = '\0';
                }
            }
            continue;
        }

        if (strstr(line, "Too many fingerprints match this host") != NULL ||
            strstr(line, "No exact OS matches for host") != NULL ||
            strstr(line, "No OS matches") != NULL) {
            printf("%s%s%s", CLR_GRAY, line, CLR_RESET);
            if (current_ip[0]) {
                int idx = -1;
                for (int i = 0; i < entry_count; ++i) {
                    if (strcmp(entries[i].ip, current_ip) == 0) { idx = i; break; }
                }
                if (idx >= 0) {
                    if (entries[idx].cls == CLS_UNKNOWN) entries[idx].cls = CLS_GRAY;
                    if (entries[idx].os_str[0] == '\0') strncpy(entries[idx].os_str, "Unknown", sizeof(entries[idx].os_str)-1);
                }
            }
            continue;
        }

        fputs(line, stdout);
    }

    fclose(rf);
    int status = 0;
    waitpid(pid, &status, 0);
    if (WIFEXITED(status) && WEXITSTATUS(status) != 0) {
        fprintf(stderr, "nmap exited with code %d\n", WEXITSTATUS(status));
    }
    return 0;
}

static char *write_gray_hosts_file(struct ip_entry *entries, int entry_count) {
    char path[PATH_MAX];
    snprintf(path, sizeof(path), "/tmp/gray_hosts_%d.txt", (int)getpid());
    FILE *f = fopen(path, "w");
    if (!f) return NULL;
    int any = 0;
    for (int i = 0; i < entry_count; ++i) {
        if (entries[i].cls == CLS_GRAY || entries[i].cls == CLS_UNKNOWN) {
            fprintf(f, "%s\n", entries[i].ip);
            any = 1;
        }
    }
    fclose(f);
    if (!any) {
        unlink(path);
        return NULL;
    }
    return strdup(path);
}

static int write_scanned_summary(const char *path, struct ip_entry *entries, int entry_count) {
    FILE *f = fopen(path, "w");
    if (!f) {
        perror("fopen scanned.txt");
        return -1;
    }
    for (int i = 0; i < entry_count; ++i) {
        const char *osdp = entries[i].os_str[0] ? entries[i].os_str : "Unknown";
        const char *c = class_name(entries[i].cls);
        fprintf(f, "%s | %s | %s\n", entries[i].ip, osdp, c);
    }
    fclose(f);
    return 0;
}

static void print_final_summary(struct ip_entry *entries, int entry_count) {
    int red=0,yellow=0,green=0,gray=0,unknown=0;
    for (int i = 0; i < entry_count; ++i) {
        switch (entries[i].cls) {
            case CLS_RED: red++; break;
            case CLS_YELLOW: yellow++; break;
            case CLS_GREEN: green++; break;
            case CLS_GRAY: gray++; break;
            default: unknown++; break;
        }
    }
    printf("\n--- OS Classification Summary ---\n");
    printf("%sRed%s (Weak): %d\n", CLR_RED, CLR_RESET, red);
    printf("%sYellow%s (Medium): %d\n", CLR_YELLOW, CLR_RESET, yellow);
    printf("%sGreen%s (Strong): %d\n", CLR_GREEN, CLR_RESET, green);
    printf("%sGray%s (Unknown): %d\n", CLR_GRAY, CLR_RESET, gray + unknown);
}

static void print_usage(const char *pname) {
    printf("Usage: %s [iface] [-n] [-t seconds]\n", pname);
    printf("  iface       - interface (default wlan1)\n");
    printf("  -n          - after bettercap run nmap with OS detection on found IPs\n");
    printf("  -t seconds  - bettercap scan time in seconds (default 8)\n");
}

int main(int argc, char **argv) {
    const char *iface = "wlan1";
    int do_nmap = 0;
    int scan_seconds = 8;

    int ai = 1;
    if (ai < argc && argv[ai][0] != '-') {
        iface = argv[ai++];
    }
    for (; ai < argc; ++ai) {
        if (strcmp(argv[ai], "-n") == 0) do_nmap = 1;
        else if (strcmp(argv[ai], "-h") == 0 || strcmp(argv[ai], "--help") == 0) {
            print_usage(argv[0]);
            return 0;
        } else if (strcmp(argv[ai], "-t") == 0) {
            if (ai + 1 >= argc) { fprintf(stderr, "-t requires an argument\n"); return 1; }
            scan_seconds = atoi(argv[++ai]);
            if (scan_seconds <= 0) scan_seconds = 8;
        } else {
            fprintf(stderr, "Unknown arg: %s\n", argv[ai]);
            print_usage(argv[0]);
            return 1;
        }
    }

    if (!sanitize_iface(iface)) {
        fprintf(stderr, "Invalid interface name: %s\n", iface);
        return 1;
    }

    if (geteuid() != 0) {
        fprintf(stderr, "Warning: running as root is recommended (bettercap and nmap -O require privileges).\n");
    }

    char *caplet_path = write_temp_caplet(iface, scan_seconds);
    if (!caplet_path) {
        fprintf(stderr, "Failed to create temporary caplet\n");
        return 1;
    }
    fprintf(stderr, "Created temporary caplet: %s\n", caplet_path);
    fprintf(stderr, "Running bettercap for %d seconds...\n", scan_seconds);

    struct ip_entry entries[MAX_IPS];
    int entry_count = 0;
    memset(entries, 0, sizeof(entries));

    if (run_bettercap_and_collect(iface, caplet_path, entries, &entry_count) != 0) {
        fprintf(stderr, "Error running bettercap\n");
        unlink(caplet_path);
        free(caplet_path);
        return 1;
    }

    if (entry_count == 0) {
        fprintf(stderr, "No hosts found in bettercap output.\n");
    } else {
        fprintf(stderr, "Found %d unique IPs. Writing hosts.txt\n", entry_count);
        if (write_hosts_file("hosts.txt", entries, entry_count) != 0) {
            unlink(caplet_path);
            free(caplet_path);
            return 1;
        }
        fprintf(stderr, "hosts.txt created (one IP per line)\n");
    }

    unlink(caplet_path);
    free(caplet_path);

    if (do_nmap && entry_count > 0) {
        fprintf(stderr, "Running first-pass nmap -O -iL hosts.txt ...\n");
        char *const nmap1_argv[] = { "nmap", "-O", "-iL", "hosts.txt", NULL };
        if (run_nmap_and_update("nmap", nmap1_argv, entries, entry_count) != 0) {
            fprintf(stderr, "Error running nmap first pass\n");
            return 1;
        }

        char *gray_hosts = write_gray_hosts_file(entries, entry_count);
        if (gray_hosts) {
            fprintf(stderr, "\nFound ambiguous/unknown hosts, running second-pass nmap (--osscan-guess -Pn -T4) on gray hosts: %s\n", gray_hosts);
            char *const nmap2_argv[] = { "nmap", "-O", "--osscan-guess", "-Pn", "-T4", "-iL", gray_hosts, NULL };
            if (run_nmap_and_update("nmap", nmap2_argv, entries, entry_count) != 0) {
                fprintf(stderr, "Error running nmap second pass\n");
                unlink(gray_hosts);
                free(gray_hosts);
                return 1;
            }
            unlink(gray_hosts);
            free(gray_hosts);
        } else {
            fprintf(stderr, "No ambiguous hosts found — skipping second-pass nmap.\n");
        }

        print_final_summary(entries, entry_count);

        if (write_scanned_summary("scanned.txt", entries, entry_count) != 0) {
            fprintf(stderr, "Failed to write scanned.txt\n");
        } else {
            fprintf(stderr, "scanned.txt written with %d entries\n", entry_count);
        }
    } else if (do_nmap) {
        fprintf(stderr, "No IPs to scan — nmap will not be run.\n");
    } else {
        printf("If you want OS detection: sudo %s %s -n -t %d\n", argv[0], iface, scan_seconds);
    }

    return 0;
}

